<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on nwidger </title>
    <link>http://nwidger.github.io/blogpost.xml</link>
    <language>en-us</language>
    <author>Niels Widger</author>
    <rights>Copyright (c) 2013, Niels Widger; all rights reserved.</rights>
    <updated>2014-01-20 00:00:00 &#43;0000 UTC</updated>
    
    <item>
      <title>Writing an NES emulator in Go, Part 3</title>
      <link>http://nwidger.github.io/post/writing-an-nes-emulator-in-go-part-3/</link>
      <pubDate>Mon, 20 Jan 2014 00:00:00 UTC</pubDate>
      <author>Niels Widger</author>
      <guid>http://nwidger.github.io/post/writing-an-nes-emulator-in-go-part-3/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m writing an NES emulator in Go and writing posts about it as I go
along.  If you haven&amp;rsquo;t read them yet, go check out the
&lt;a href=&#34;/post/writing-an-nes-emulator-in-go-part-1&#34;&gt;first&lt;/a&gt; and
&lt;a href=&#34;/post/writing-an-nes-emulator-in-go-part-2&#34;&gt;second&lt;/a&gt; post.&lt;/p&gt;

&lt;h2&gt;Package Layout&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been trying to implement each major NES component as a reuseable
module.  Each module is stored in a separate GitHub repository.
Here&amp;rsquo;s the layout I&amp;rsquo;m using right now:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;m65go2&lt;/code&gt; - &lt;a href=&#34;https://github.com/nwidger/m65go2/&#34;&gt;GitHub&lt;/a&gt; - The
MOS 6502 CPU.  Defines the &lt;code&gt;M6502&lt;/code&gt; type.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;rp2ago3&lt;/code&gt; - &lt;a href=&#34;https://github.com/nwidger/rp2ago3/&#34;&gt;GitHub&lt;/a&gt; - The
RP2A03 CPU (a MOS 6502 chip plus an APU) used in the NES.  Embeds an
&lt;code&gt;M6502&lt;/code&gt; instance from the &lt;code&gt;m65go2&lt;/code&gt; package along with a new &lt;code&gt;APU&lt;/code&gt;
type to form a new &lt;code&gt;RP2A03&lt;/code&gt; type.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;rp2cgo2&lt;/code&gt; - &lt;a href=&#34;https://github.com/nwidger/rp2cgo2/&#34;&gt;GitHub&lt;/a&gt; - The
RP2C02 PPU used in the NES.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once everything is implemented, I will create a fourth package called
something clever like &lt;code&gt;nintengo&lt;/code&gt; which combines &lt;code&gt;RP2A03&lt;/code&gt; and &lt;code&gt;RP2C02&lt;/code&gt;
instances to form a full NES.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a diagram for how it all fits together:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;+---------------------+
|       RP2A03        |
| +-------+ +-------+ |
| | M6502 | |  APU  | |
| +-------+ +-------+ |
+---------------------+
                |
               /
---Clock------*
21.477272Mhz   \
                |
+---------------------+
|                     |
|       RP2C02        |
|                     |
+---------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Clock Divisors&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;rp2ago3&lt;/code&gt; package must divide the 21.477272Mhz external clock
signal by twelve internally to produce the 1.789773Mhz signal used by
the M6502/APU chips.  To do this, I created a &lt;code&gt;Clocker&lt;/code&gt; interface
which implements the methods of &lt;code&gt;Clock&lt;/code&gt;, the basic clock type I
created for the &lt;code&gt;m65go2&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Represents a clock signal for an IC.  Once a Clock is started, it
// maintains a &#39;ticks&#39; counters which is incremented at a specific
// interval.
type Clocker interface {
    // Returns the current value of the Clocker&#39;s ticks counter.
    Ticks() uint64

    // Starts the clock
    Start() (ticks uint64)

    // Stops the clock
    Stop()

    // Blocks the calling thread until the given tick has arrived.
    // Returns immediately if the clock has already passed the
    // given tick.
    Await(tick uint64) (ticks uint64)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously, the base &lt;code&gt;Clock&lt;/code&gt; type implements this interface.  Next, I
created a &lt;code&gt;Divider&lt;/code&gt; type which gets passed a &lt;code&gt;Clocker&lt;/code&gt; instance and
divisor on creation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Returns a pointer to a new DividerCLock which divides the tick rate
// of &#39;master&#39; Clocker by &#39;divisor&#39;.
func NewDivider(master Clocker, divisor uint64) *Divider {
    return &amp;amp;Divider{divisor: divisor, master: master}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Divider&lt;/code&gt; implements its own version of &lt;code&gt;Start&lt;/code&gt;, &lt;code&gt;Stop&lt;/code&gt; and &lt;code&gt;Await&lt;/code&gt;
which use the base clock but ensure the module using a &lt;code&gt;Divider&lt;/code&gt; will
only see a tick after every Nth tick from the base clock:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (clock *Divider) Ticks() uint64 {
    return clock.master.Ticks() / clock.divisor
}

func (clock *Divider) Start() (ticks uint64) {
    return clock.master.Start() / clock.divisor
}

func (clock *Divider) Stop() {
    clock.master.Stop()
}

func (clock *Divider) Await(tick uint64) (ticks uint64) {
    return clock.master.Await(tick*clock.divisor) / clock.divisor
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I create a new &lt;code&gt;RP2A03&lt;/code&gt; instance, I create a &lt;code&gt;Divider&lt;/code&gt; instance
to divide the base clock passed into &lt;code&gt;NewRP2A03&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func NewRP2A03(mem *MappedMemory, clock m65go2.Clocker, divisor uint64) *RP2A03 {
    ...
    divider := m65go2.NewDivider(clock, divisor)
    cpu := m65go2.NewM6502(mem, divider)
    apu := NewAPU(divider)
    ...
    return &amp;amp;RP2A03{memory: mem, M6502: cpu, APU: apu, clock: divider}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Memory Maps&lt;/h2&gt;

&lt;p&gt;I struggled for a while trying to figure how best to implement the
memory mapped I/O used on the NES.  Since the MOS 6502 has no I/O
lines into it, both the APU and PPU must map their internal registers
into the 6502&amp;rsquo;s address space.  The solution I wound up using is very
simple, but seems to be working so far.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;m65go2&lt;/code&gt; package defines the &lt;code&gt;Memory&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Represents the RAM memory available to the 6502 CPU.  Stores 8-bit
// values using a 16-bit address for a total of 65,536 possible 8-bit
// values.
type Memory interface {
    Reset()                                             // Sets all memory locations to zero
    Fetch(address uint16) (value uint8)                 // Returns the value stored at the given memory address
    Store(address uint16, value uint8) (oldValue uint8) // Stores the value at the given memory address
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;rp2ago3&lt;/code&gt; package defines the &lt;code&gt;MappedMemory&lt;/code&gt; type which implements
the &lt;code&gt;Memory&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type MappedMemory struct {
    maps map[uint16]m65go2.Memory
    m65go2.Memory
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second field &lt;code&gt;m65go2.Memory&lt;/code&gt; does not have a name since it is an
&amp;ldquo;anonymous&amp;rdquo; or &amp;ldquo;embedded&amp;rdquo; field in Go parlance.  When a field is
declared without a name it is &amp;ldquo;embedded&amp;rdquo; meaning the new type
automatically gains the functions implemented by the embedded type
without the tedium of having to add a bunch of wrapper methods like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (parent MyParentType) myFunction() {
        parent.embeddedField.myFunction()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since Go provides interfaces but not classes with the ability to
extend an existing class, embedding gets you halfway there by letting
you create a new type that automatically implements all methods (and
therefore all interfaces) provided by the embedded type.&lt;/p&gt;

&lt;p&gt;Anyways, the &lt;code&gt;maps&lt;/code&gt; field in the &lt;code&gt;MappedMemory&lt;/code&gt; struct stores the
addresses in memory which are mapped elsewhere.  For each mapped
address, we store a &lt;code&gt;Memory&lt;/code&gt; instance.  When &lt;code&gt;Fetch&lt;/code&gt; or &lt;code&gt;Store&lt;/code&gt; is
called on the &lt;code&gt;MappedMemory&lt;/code&gt; instance, we first check if the address
is mapped to another &lt;code&gt;Memory&lt;/code&gt; instance and pass it off, otherwise we
call the appropriate method of the embedded &lt;code&gt;Memory&lt;/code&gt; instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (mem *MappedMemory) Fetch(address uint16) (value uint8) {
    if mmap, ok := mem.maps[address]; ok {
        return mmap.Fetch(address)
    }

    return mem.Memory.Fetch(address)
}

func (mem *MappedMemory) Store(address uint16, value uint8) (oldValue uint8) {
    if mmap, ok := mem.maps[address]; ok {
        return mmap.Store(address, value)
    }

    return mem.Memory.Store(address, value)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The end result is that when I create a new &lt;code&gt;RP2A03&lt;/code&gt; CPU instance, I
can map the APU&amp;rsquo;s registers to the appropriate addresses in memory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func NewRP2A03(mem *MappedMemory, clock m65go2.Clocker, divisor uint64) *RP2A03 {
    ...
    apu := NewAPU(divider)

    // APU memory maps
    mem.AddMap([]uint16{
        0x4000, 0x4001, 0x4002, 0x4003, 0x4004,
        0x4005, 0x4006, 0x4007, 0x4008, 0x400a,
        0x400b, 0x400c, 0x400e, 0x400f, 0x4010,
        0x4011, 0x4012, 0x4013, 0x4015, 0x4017,
    }, apu)

    return &amp;amp;RP2A03{memory: mem, M6502: cpu, APU: apu, clock: divider}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, any &lt;code&gt;Fetch&lt;/code&gt; or &lt;code&gt;Store&lt;/code&gt; calls for those addresses will be
redirected to the &lt;code&gt;Fetch&lt;/code&gt; or &lt;code&gt;Store&lt;/code&gt; methods implemented by &lt;code&gt;APU&lt;/code&gt;.
These methods know which addresses map to which registers,
i.e. &lt;code&gt;0x4000-0x4003&lt;/code&gt; maps to the pulse 1 channel registers.&lt;/p&gt;

&lt;h2&gt;Package Visibility&lt;/h2&gt;

&lt;p&gt;When I initially began work on the emulator, I had a single Go
package.  Now that there are three separate packages I need to put
more thought into what fields/symbols of a package are exported.  In
Go, only exported fields/symbols are visible outside of a package.  Go
really only has
&lt;a href=&#34;http://golang.org/ref/spec#Exported_identifiers&#34;&gt;one rule&lt;/a&gt; that
determines what gets exported: capitalize it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type notExportedType struct { } // not exported
type ExportedType struct { }    // exported

type OtherExportedType struct {
        ExportedInt     int     // exported
        notExportedBool bool    // not exported
}

func notExportedFunc() { }      // not exported
func ExportedFunction() { }     // exported
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I spent some time going through the types I had created and modifying
their fields/methods to be exported where I deemed appropriate.  Some
obvious ones were exporting &lt;code&gt;M6502&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Register&lt;/code&gt; and &lt;code&gt;Memory&lt;/code&gt; fields,
since an external program trying to use the module would probably find
it convenient to actually be able to read/write the CPU&amp;rsquo;s registers
and access its memory.&lt;/p&gt;

&lt;h2&gt;Decimal Mode&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m not sure why I felt the need to add decimal mode support to the
&lt;code&gt;m65go2&lt;/code&gt; package, but I added it for completeness anyways.  The MOS
6502 supported an alternative form of addition/subtraction for the
&lt;code&gt;ADC&lt;/code&gt; (addition with carry) and &lt;code&gt;SBC&lt;/code&gt; (subtraction with carry)
instructions in which arguments are expected to be in packed binary
coded decimal (BCD) form instead of the normal one&amp;rsquo;s compliment
representation.&lt;/p&gt;

&lt;p&gt;Under normal binary arithmetic, you would expect to get results like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-hightlight&#34;&gt;0x45 + 0x25 = 0x6a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whereas if you&amp;rsquo;re in decimal mode and using BCD values, you get
results like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-hightlight&#34;&gt;0x45 + 0x25 = 0x70
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In decimal mode, the CPU interprets each argument as a byte
representing a two digit number in base ten, where each digit is
stored using 4-bits.&lt;/p&gt;

&lt;p&gt;I referenced &lt;a href=&#34;http://www.piumarta.com/software/lib6502/&#34;&gt;lib6502&lt;/a&gt;&amp;rsquo;s
implementation of BCD arithmetic and relied on it pretty heavily to
get things working.  Of course, there are probably plenty of bugs
remaining.  But it doesn&amp;rsquo;t matter too much since the RP2A03 CPU used
in the NES didn&amp;rsquo;t support decimal mode, apparently to
&lt;a href=&#34;https://en.wikipedia.org/wiki/Nintendo_Entertainment_System_technical_specifications#Central_processing_unit&#34;&gt;avoid patent payments&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;NES Test ROM&lt;/h2&gt;

&lt;p&gt;In one of the previous posts I lamented not being able to get a test
ROM running in my emulator.  I persevered and did eventually get the
&lt;code&gt;nestest&lt;/code&gt; test program from
&lt;a href=&#34;http://wiki.nesdev.com/w/index.php/Emulator_tests&#34;&gt;this page&lt;/a&gt; to run.
I added it to the &lt;code&gt;m65go2&lt;/code&gt; repository along with the expected output
and
&lt;a href=&#34;https://github.com/nwidger/m65go2/blob/master/test-roms/nestest.txt&#34;&gt;this text file&lt;/a&gt;.
From the file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;This here is a pretty much all inclusive test suite for a NES CPU.
It was designed to test almost every combination of flags, instructions,
and registers. Some of these tests are very difficult, and so far,
Nesten and Nesticle failed it. Nintendulator passes, as does a real
NES (naturally). I haven&#39;t tested it with any more emualtors yet.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only issue in using the test program was the question of how to
validate it.  The file comes with
&lt;a href=&#34;https://github.com/nwidger/m65go2/blob/master/test-roms/nestest.log&#34;&gt;the expected debug output from Nintendulator&lt;/a&gt;,
but it would be incredibly tedious to go through line by line and make
sure my emulator places the same values in memory and modifies each
register correctly for each instruction.  How can I integrate this
test program into the rest of my &lt;code&gt;go test&lt;/code&gt; unit tests?  The road I
went down was replicating the debug output inside my emulator to match
what Nintendulator produces.  For each instruction, Nintendulator
prints a line like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;*- instruction address (PC register)
|
|     *- opcode + args
|     |
|     |         *- mneumonic + decoded args
|     |         |
|     |         |                               *- pre-execution registers
|     |         |                               |
C000  4C F5 C5  JMP $C5F5                       A:00 X:00 Y:00 P:24 SP:FD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After perhaps three days of work the emulator now produces the same
output as Nintendulator, passes each test and implements all of the
unofficial opcodes tested by the program.  In go, an &amp;ldquo;example&amp;rdquo; test
function can be associated with an expected output that &lt;code&gt;go test&lt;/code&gt; will
verify when running the test.  I created an example test which runs
the test program and put the Nintendulator log contents as the
expected output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func ExampleRom() {
    Setup()

    cpu.DisableDecimalMode()

    cpu.Registers.P = 0x24
    cpu.Registers.SP = 0xfd
    cpu.Registers.PC = 0xc000

    cpu.Memory.(*BasicMemory).load(&amp;quot;test-roms/nestest.nes&amp;quot;)

    cpu.Memory.Store(0x4004, 0xff)
    cpu.Memory.Store(0x4005, 0xff)
    cpu.Memory.Store(0x4006, 0xff)
    cpu.Memory.Store(0x4007, 0xff)
    cpu.Memory.Store(0x4015, 0xff)

    cpu.decode.enabled = true

    cpu.Run()

    Teardown()

    // Output:
    // C000  4C F5 C5  JMP $C5F5                       A:00 X:00 Y:00 P:24 SP:FD
    // C5F5  A2 00     LDX #$00                        A:00 X:00 Y:00 P:24 SP:FD
    // C5F7  86 00     STX $00 = 00                    A:00 X:00 Y:00 P:26 SP:FD
    // C5F9  86 10     STX $10 = 00                    A:00 X:00 Y:00 P:26 SP:FD
    // C5FB  86 11     STX $11 = 00                    A:00 X:00 Y:00 P:26 SP:FD
    // C5FD  20 2D C7  JSR $C72D                       A:00 X:00 Y:00 P:26 SP:FD
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the work was definitely worth as it makes me much more confident
that most things are implemented correctly.&lt;/p&gt;

&lt;h2&gt;Up Next&lt;/h2&gt;

&lt;p&gt;Now that the CPU has been fairly well tested, it&amp;rsquo;s time to move on.  I
still need to implement the RP2C02, the PPU used in the NES, so that
will be my next step.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing an NES emulator in Go, Part 2</title>
      <link>http://nwidger.github.io/post/writing-an-nes-emulator-in-go-part-2/</link>
      <pubDate>Sat, 04 Jan 2014 00:00:00 UTC</pubDate>
      <author>Niels Widger</author>
      <guid>http://nwidger.github.io/post/writing-an-nes-emulator-in-go-part-2/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m writing an NES emulator in Go and writing posts about it as I go
along.  If you haven&amp;rsquo;t read it yet, the first post can be
&lt;a href=&#34;/post/writing-an-nes-emulator-in-go-part-1&#34;&gt;found here&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Progress&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve made significant progress on the 6502 code.  All of the
instructions have been implemented and the emulator executes each
instruction in the correct number of cycles, keeping in step with the
external clock signal.  You can look at the code at the GitHub
repository &lt;a href=&#34;https://github.com/nwidger/m65go2&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Timing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Clock&lt;/code&gt; type hasn&amp;rsquo;t changed very much since the first post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;
type Clock struct {
    rate     time.Duration
    ticks    uint64
    ticker   *time.Ticker
    stopChan chan int
    waiting  map[uint64][]chan int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The major change is that the clock now maintains a &lt;code&gt;ticks&lt;/code&gt; field which
counts the number of cycles elapsed since the clock was started.  The
clock&amp;rsquo;s &lt;code&gt;start&lt;/code&gt; method kicks off the &lt;code&gt;maintainTime&lt;/code&gt; function in a new
goroutine.  The new goroutine performs two functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Increment &lt;code&gt;ticks&lt;/code&gt; whenever the ticker fires.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Wake up any other threads waiting for a specific tick to arrive.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (clock *Clock) maintainTime() {
    for {
        select {
        case &amp;lt;-clock.stopChan:
            clock.ticker = nil
            return
        case _ = &amp;lt;-clock.ticker.C:
            clock.ticks++

            if Ca, ok := clock.waiting[clock.ticks]; ok {
                for _, C := range Ca {
                    C &amp;lt;- 1
                }

                delete(clock.waiting, clock.ticks)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;waiting&lt;/code&gt; field maps ticker values to a slice of channels used to
signal other threads waiting for that particular clock tick to arrive
(a slice in Go is an array which grows and shrinks dynamically).&lt;/p&gt;

&lt;p&gt;In CPU&amp;rsquo;s &lt;code&gt;Execute&lt;/code&gt; method, after an opcode executes it returns the
number of cycles to wait for.  We first multiply this by the CPU clock
divisor of twelve (the master clock runs at 21.477272Mhz but the CPU
divides that by twelve to run at 1.789773Mhz) and then wait for this
many cycles past the current tick using the clock&amp;rsquo;s &lt;code&gt;await&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (cpu *Cpu) Execute() (cycles uint16, error error) {
    ticks := cpu.clock.ticks

    // fetch
    opcode := OpCode(cpu.memory.fetch(cpu.registers.PC))
    inst, ok := cpu.instructions[opcode]

    if !ok {
        return 0, BadOpCodeError(opcode)
    }

    // execute
    cpu.registers.PC++
    cycles = inst.exec(cpu)

    // count cycles
    cpu.clock.await(ticks + uint64(cycles*cpu.divisor))

    return cycles, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The clock&amp;rsquo;s &lt;code&gt;await&lt;/code&gt; method is very simple.  If the tick we want hasn&amp;rsquo;t
arrived yet, we append a new buffered channel to the entry in the
&lt;code&gt;waiting&lt;/code&gt; map for the tick we want and then try to read from the
channel (that&amp;rsquo;s what &lt;code&gt;&amp;lt;-C&lt;/code&gt; is doing) which will cause us to block.
When &lt;code&gt;maintainTime&lt;/code&gt; arrives at our tick, it will write an integer into
the channel thus waking us up and allowing us to return to the
&lt;code&gt;Execute&lt;/code&gt; frame.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (clock *Clock) await(tick uint64) uint64 {
    if clock.ticks &amp;lt; tick {
        C := make(chan int, 1)
        clock.waiting[tick] = append(clock.waiting[tick], C)
        &amp;lt;-C
    }

    return clock.ticks
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Unit Testing in Go&lt;/h2&gt;

&lt;p&gt;I used Go&amp;rsquo;s unit testing framework to write tests for each
instruction.  Unit testing is provided in Go using the
&lt;a href=&#34;http://golang.org/pkg/testing/&#34;&gt;testing&lt;/a&gt; package and the
&lt;a href=&#34;http://golang.org/cmd/go/#hdr-Test_packages&#34;&gt;go test&lt;/a&gt; command.
There&amp;rsquo;s a short explanation about it
&lt;a href=&#34;http://golang.org/doc/code.html#Testing&#34;&gt;here&lt;/a&gt;.  You can take a peek
at the tests
&lt;a href=&#34;https://github.com/nwidger/m65go2/blob/master/instructions_test.go&#34;&gt;here&lt;/a&gt;
if you want.&lt;/p&gt;

&lt;p&gt;To test each instruction in my 6502 emulator, I first created a new
file &lt;code&gt;instructions_test.go&lt;/code&gt; (the &lt;code&gt;go test&lt;/code&gt; command runs all tests in
files that end with &lt;code&gt;_test.go&lt;/code&gt;).  For each instruction, I wrote at
least one test as a function with a signature like &lt;code&gt;func
TestLdaImmediate(t *testing.T)&lt;/code&gt;.  The &lt;code&gt;go test&lt;/code&gt; command runs all
functions with the signature &lt;code&gt;func TestXXX(t *testing.T)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since I needed to setup/teardown the CPU and clock for each test, I
wrote a pair of functions to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package m65go2

import (
    &amp;quot;testing&amp;quot;
    &amp;quot;time&amp;quot;
)

const rate time.Duration = 46 * time.Nanosecond // 21.477272Mhz
const divisor = 12

var cpu *Cpu

func Setup() {
    clock := NewClock(rate)
    cpu = NewCpu(NewBasicMemory(), divisor, clock)
    cpu.Reset()
    go clock.start()
}

func Teardown() {
    cpu.clock.stop()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each test function calls &lt;code&gt;Setup&lt;/code&gt;/&lt;code&gt;Teardown&lt;/code&gt; at the beginning/end of
each test to ensure everything starts at a well-known state:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func TestLdaImmediate(t *testing.T) {
    Setup()

    cpu.registers.PC = 0x0100

    cpu.memory.store(0x0100, 0xa9)
    cpu.memory.store(0x0101, 0xff)

    cpu.Execute()

    if cpu.registers.A != 0xff {
        t.Error(&amp;quot;Register A is not 0xff&amp;quot;)
    }

    Teardown()
}

func TestLdaZeroPage(t *testing.T) {
    Setup()

    cpu.registers.PC = 0x0100

    cpu.memory.store(0x0100, 0xa5)
    cpu.memory.store(0x0101, 0x84)
    cpu.memory.store(0x0084, 0xff)

    cpu.Execute()

    if cpu.registers.A != 0xff {
        t.Error(&amp;quot;Register A is not 0xff&amp;quot;)
    }

    Teardown()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Failing a test is easy, just call &lt;code&gt;t.Error&lt;/code&gt;, passing it a reason
string.&lt;/p&gt;

&lt;p&gt;The unit tests ensure a number of things about each instruction:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The instruction modifies the appropriate memory addresses or
registers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The bits of status register &lt;code&gt;P&lt;/code&gt; are set/cleared correctly&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The instruction executes in the correct number of clock cycles&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Many instructions have multiple opcodes, each using a different
addressing mode.  There is a test for each opcode to ensure it
really uses that addressing mode correctly.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All in all there are about 270 tests total.  Whenever I make a change
to the codebase, I can be fairly confident that I haven&amp;rsquo;t broken
anything major by running the unit tests:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;macros:m65go2 nwidger$ go test
PASS
ok      github.com/nwidger/m65go2   0.815s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I found the code coverage tool very useful while writing my tests.
This feature works by writing a coverage profile to disk when &lt;code&gt;go
test&lt;/code&gt; is run.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;macros:m65go2 nwidger$ go test -coverprofile=coverage.out
PASS
coverage: 89.9% of statements
ok      github.com/nwidger/m65go2   0.830s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Later, &lt;code&gt;go tool cover&lt;/code&gt; can use a coverage profile to display coverage
information either as a simple textfile or an HTML page.  The textfile
format is a simple table with percentages for each function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;macros:m65go2 nwidger$ go tool cover -func=coverage.out
github.com/nwidger/m65go2/cpu.go:       absoluteIndexedAddress  100.0%
github.com/nwidger/m65go2/cpu.go:       indexedIndirectAddress  100.0%
github.com/nwidger/m65go2/cpu.go:       indirectIndexedAddress  100.0%
github.com/nwidger/m65go2/cpu.go:       Lda         66.7%
github.com/nwidger/m65go2/cpu.go:       Ldx         66.7%
github.com/nwidger/m65go2/cpu.go:       Ldy         66.7%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The HTML page shows the code coverage of your tests in an extremely
visual manner.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;go tool cover -html=coverage.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see example output of &lt;code&gt;go tool cover -html&lt;/code&gt; on
&lt;a href=&#34;/html/coverage.html&#34;&gt;this page&lt;/a&gt;.  You can select the file to view
from the pull-down at the top-left of the page.&lt;/p&gt;

&lt;h2&gt;Test Programs&lt;/h2&gt;

&lt;p&gt;I also tried running a
&lt;a href=&#34;http://2m5.de/6502_Emu/6502_functional_tests.zip&#34;&gt;6502 functional test program&lt;/a&gt;
inside my emulator but kept running into problems.  The documentation
says the &lt;code&gt;PC&lt;/code&gt; register should be set to &lt;code&gt;$1000&lt;/code&gt; but after looking at
the test image in a hex editor (thanks
&lt;a href=&#34;https://www.gnu.org/software/emacs/manual/html_node/emacs/Editing-Binary-Files.html&#34;&gt;hexl-mode&lt;/a&gt;)
that location contains an illegal opcode.  Furthermore, after
comparing the assembler file with the assembled binary image, it&amp;rsquo;s
clear that some of the absolute addresses in &lt;code&gt;JMP&lt;/code&gt; instructions are
off but 4-10 bytes.  Either way, I was unable to get the test program
to run without encountering an illegal opcode and crashing.
Fortunately, I did get it to run enough to at least assure me that the
basic fetch/execute cycle works properly.  I may go back and try to
get a test program running, as it would give me even greater assurance
that everything is implemented correctly.&lt;/p&gt;

&lt;h2&gt;Up Next&lt;/h2&gt;

&lt;p&gt;The next big implementation job is to start implementing the PPU
(Picture Processing Unit) used in the NES, which is a 2C02 chip.  The
PPU has eight registers which are mapped into the CPU&amp;rsquo;s address space
between &lt;code&gt;$2000&lt;/code&gt; and &lt;code&gt;$2007&lt;/code&gt;.  I have a feeling I still have a lot of
reading to do before I&amp;rsquo;ll understand how the PPU works enough to start
implementing it.  I&amp;rsquo;m still on the fence about how to do the memory
mapping, but I have some ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing an NES emulator in Go, Part 1</title>
      <link>http://nwidger.github.io/post/writing-an-nes-emulator-in-go-part-1/</link>
      <pubDate>Sat, 28 Dec 2013 00:00:00 UTC</pubDate>
      <author>Niels Widger</author>
      <guid>http://nwidger.github.io/post/writing-an-nes-emulator-in-go-part-1/</guid>
      <description>&lt;h2&gt;Motivation&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve decided to write my own NES emulator in Go.  I know that many,
many NES emulators have been written over the years
(&lt;a href=&#34;https://github.com/scottferg/Fergulator/&#34;&gt;at least one&lt;/a&gt; written in
Go), but I&amp;rsquo;ve always wanted to try writing my own emulator after using
them for many years.  Plus it gives me a good reason to program in Go
some more.  I plan to do a post every so often as the emulator
progresses.  Hopefully I don&amp;rsquo;t lose interest half-way through!  I&amp;rsquo;ll
be putting the source code for the project up on
&lt;a href=&#34;https://github.com/nwidger/m65go2&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;

&lt;h2&gt;Architecture&lt;/h2&gt;

&lt;p&gt;My first task is to write a simulator for the CPU used by the NES, the
MOS 6502.  The 6502 chip used in the NTSC NES runs at 1.789773Mhz, or
1,789,773 cycles per second.  The NES&amp;rsquo;s 6502 does not support decimal
mode, meaning a few instructions don&amp;rsquo;t need to be supported which is
goood.&lt;/p&gt;

&lt;p&gt;The MOS 6502 is an 8-bit processor with 16-bit addresses
(little-endian, so it expects the least significant byte of each
16-bit address to be stored first in memory).  It has no I/O lines, so
any I/O registers must be mapped into the 16-bit address space.  A
full listing of the 6502&amp;rsquo;s instruction set can be found
&lt;a href=&#34;http://www.obelisk.demon.co.uk/6502/registers.html&#34;&gt;here&lt;/a&gt; and
&lt;a href=&#34;http://www.6502.org/tutorials/6502opcodes.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Registers&lt;/h2&gt;

&lt;p&gt;All registers are 8-bit unless otherwise noted.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Accumulator (&lt;code&gt;A&lt;/code&gt;) - The &lt;code&gt;A&lt;/code&gt; register is used for all arithmetic and
logic instructions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Index Register 1 &amp;amp; 2 (&lt;code&gt;X&lt;/code&gt; &amp;amp; &lt;code&gt;Y&lt;/code&gt;) - Registers &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; are used
for indirect addressing and also as counters/indexes.  &lt;code&gt;X&lt;/code&gt; is used
by certain instructions to save/restore the value of &lt;code&gt;P&lt;/code&gt; using the
stack.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stack Pointer (&lt;code&gt;SP&lt;/code&gt;) - Stores the least-significant byte of the top
of the stack.  The 6502&amp;rsquo;s stack is hardwired to occupy &lt;code&gt;$0100&lt;/code&gt; -
&lt;code&gt;$01ff&lt;/code&gt; with &lt;code&gt;SP&lt;/code&gt; initalized to &lt;code&gt;$ff&lt;/code&gt; at power-up.  If the value of
&lt;code&gt;SP&lt;/code&gt; is &lt;code&gt;$84&lt;/code&gt; then the top of the stack is located at &lt;code&gt;$0184&lt;/code&gt;.  The
top of the stack moves downward in memory as values are pushed and
upward as values are popped.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Program Counter (&lt;code&gt;PC&lt;/code&gt;) - The only 16-bit register on the 6502, &lt;code&gt;PC&lt;/code&gt;
points to the next instruction to execute.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Processor Status (&lt;code&gt;P&lt;/code&gt;) - The bits in &lt;code&gt;P&lt;/code&gt; indicate the results of the
last arithmetic and logic instructions as well as indicate if a
break/interrupt instruction has just been executed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bit 0 - Carry Flag (&lt;code&gt;C&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Bit 1 - Zero Flag (&lt;code&gt;Z&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Bit 2 - Interrupt Disable (&lt;code&gt;I&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Bit 3 - Decimal Mode (&lt;code&gt;D&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Bit 4 - Break Command (&lt;code&gt;B&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Bit 5 - -UNUSED-&lt;/li&gt;
&lt;li&gt;Bit 6 - Overflow Flag (&lt;code&gt;O&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Bit 7 - Negative Flag (&lt;code&gt;N&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More information on the 6502&amp;rsquo;s registers can be found
&lt;a href=&#34;http://www.obelisk.demon.co.uk/6502/registers.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Memory Map&lt;/h2&gt;

&lt;p&gt;The 6502&amp;rsquo;s memory layout is very simple.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;$0000&lt;/code&gt; - &lt;code&gt;$00ff&lt;/code&gt; - Used by zero page addressing instructions.
Instructions using zero page addressing only require an 8-bit
address parameter.  The most-signficant 8-bits of the address are
assumed to be &lt;code&gt;$00&lt;/code&gt;.  This is done to save memory since the address
requires half the space.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$0100&lt;/code&gt; - &lt;code&gt;$01ff&lt;/code&gt; - Reserved for the system stack.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$0200&lt;/code&gt; - &lt;code&gt;$fff9&lt;/code&gt; - Unspecified&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;fff$a&lt;/code&gt; - &lt;code&gt;$fffb&lt;/code&gt; - Contains address of non-maskable interrupt (NMI) handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$fffc&lt;/code&gt; - &lt;code&gt;$fffd&lt;/code&gt; - Contains address of reset location&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$fffe&lt;/code&gt; - &lt;code&gt;$ffff&lt;/code&gt; - Contains address of BRK/IRQ handler&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Implementation&lt;/h2&gt;

&lt;p&gt;Implementing the CPU is simply a matter of creating a representation
of the CPU&amp;rsquo;s internals and input/output lines and then writing
functions which implement the 6502&amp;rsquo;s instruction set.&lt;/p&gt;

&lt;h3&gt;Memory&lt;/h3&gt;

&lt;p&gt;Memory can simply be a 65,536 (16-bit address bus, so &lt;code&gt;2^16&lt;/code&gt;
addresses) element &lt;code&gt;uint8&lt;/code&gt; array.  Reads/writes to memory merely get
and set elements in the array.  For now I will use a very simple
&lt;code&gt;BasicMemory&lt;/code&gt; type to emulate the 6502&amp;rsquo;s RAM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type Memory interface {
    reset()
    fetch(address uint16) (value uint8)
    store(address uint16, value uint8) (oldValue uint8)
}

type BasicMemory [65536]uint8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to handle the memory mapping done by the NES, I will need to
create an &lt;code&gt;NESMemory&lt;/code&gt; type which implements the &lt;code&gt;Memory&lt;/code&gt; interface but
whose &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; functions understand the NES&amp;rsquo;s memory
layout.  Specifically, a number of memory ranges are either mirrored
to other memory ranges, memory mapped to registers of the PPU (Picture
Processing Unit) and APU (Audio Processing Unit), or mapped to the
actual NES cartridge.  See
&lt;a href=&#34;http://wiki.nesdev.com/w/index.php/CPU_memory_map&#34;&gt;here&lt;/a&gt; for details.&lt;/p&gt;

&lt;h3&gt;CPU&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Cpu&lt;/code&gt; type stores the 6502&amp;rsquo;s registers and instruction table as
well as a clock input and a link off to memory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type Status uint8

const (
    C Status = 1 &amp;lt;&amp;lt; iota // carry flag
    Z                    // zero flag
    I                    // interrupt disable
    D                    // decimal mode
    B                    // break command
    _                    // -UNUSED-
    V                    // overflow flag
    N                    // negative flag
)

type Registers struct {
    A  uint8  // accumulator
    X  uint8  // index register X
    Y  uint8  // index register Y
    P  Status // processor status
    SP uint8  // stack pointer
    PC uint16 // program counter
}

type Cpu struct {
    clock        Clock
    registers    Registers
    memory       Memory
    instructions InstructionTable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Fetch/Execute Cycle&lt;/h3&gt;

&lt;p&gt;The fetch/execute cycle of the emulator fetches the instruction at the
address stored in the &lt;code&gt;PC&lt;/code&gt; register, looks up the opcode in its
instruction table and then executes it.  Each instruction should be in
charge of modifying the stack/registers/memory appropriately as well
as incrementing the &lt;code&gt;PC&lt;/code&gt; register appropriately for the number of
parameters (or using the value of the parameters, in the case of
branching instructions).  Each instruction also needs to determine how
many clock cycles it should use up, since some instructions take
different number of clock cycles depending on their parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (cpu *Cpu) Execute() {
    // fetch
    opcode := OpCode(cpu.memory.fetch(cpu.registers.PC))
    inst, ok := cpu.instructions[opcode]

    if !ok {
        fmt.Printf(&amp;quot;No such opcode 0x%x\n&amp;quot;, opcode)
        os.Exit(1)
    }

    // execute, exec() returns number of cycles
    cycles := inst.exec(cpu)

    // count cycles
    for _ = range cpu.clock.ticker.C {
        cycles--

        if cycles == 0 {
            break
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Clock&lt;/h3&gt;

&lt;p&gt;One tricky point in the implementation is going to be timing.  For the
6502 to interact properly with other components of the NES such as the
PPU and APU, it must execute instructions in a specific amount of time
and stay in sync with the master clock.  According to the 6502
specification, each instruction takes a deterministic number of clock
cycles to execute.  Since it can probably be taken for granted that a
modern machine will be able to execute each instruction faster than a
real 6502 chip, the emulator will need to throttle the CPU to ensure
it does not execute too quickly.  I plan to look into Go&amp;rsquo;s
&lt;a href=&#34;http://golang.org/pkg/time/&#34;&gt;time&lt;/a&gt; package, specifically the Ticker
data type, to implement the clock signal used by the 6502.  This is
definitely the part I&amp;rsquo;m worried about the most.&lt;/p&gt;

&lt;h2&gt;Up Next&lt;/h2&gt;

&lt;p&gt;I have the basic architecture written, but so far I&amp;rsquo;ve only
implemented the &lt;code&gt;LDA&lt;/code&gt; instruction.  After implementing the rest of the
instruction set I will need to write a number of unit tests to ensure
everything is working properly.  This should give me a chance to try
out Go&amp;rsquo;s
&lt;a href=&#34;http://golang.org/doc/code.html#Testing&#34;&gt;unit testing framework&lt;/a&gt;,
specifically Go 1.2&amp;rsquo;s new
&lt;a href=&#34;http://golang.org/doc/go1.2#cover&#34;&gt;test coverage&lt;/a&gt; features (here&amp;rsquo;s a
great &lt;a href=&#34;http://blog.golang.org/cover&#34;&gt;blog post&lt;/a&gt; about the feature).&lt;/p&gt;

&lt;h2&gt;Resources&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been using the following sites to help in implementing the 6502
and learn about the internals of the NES.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.nesdev.com/&#34;&gt;NESDev Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.6502.org/tutorials/6502opcodes.html&#34;&gt;6502.org NMOS 6502 Opcodes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.obelisk.demon.co.uk/6502/index.html&#34;&gt;6502 Introduction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Neeman-Marcus Cookies</title>
      <link>http://nwidger.github.io/post/neeman-marcus-cookies</link>
      <pubDate>Sat, 21 Dec 2013 00:00:00 UTC</pubDate>
      <author>Niels Widger</author>
      <guid>http://nwidger.github.io/post/neeman-marcus-cookies</guid>
      <description>&lt;p&gt;I got this recipe from my father who used to make these all the time.
I&amp;rsquo;ve made them for various events the last few years and people seem
to like them.&lt;/p&gt;

&lt;div class=&#34;thumbnail&#34;&gt;
  &lt;a href=&#39;/images/neeman-marcus-cookies.jpg&#39; data-lightbox=&#39;cookies&#39; title=&#39;Om nom nom&#39;&gt;&lt;img src=&#39;/images/neeman-marcus-cookies.jpg&#39;&gt;&lt;/a&gt;

  
  &lt;div class=&#34;caption&#34;&gt;
    &lt;p&gt;
      Om nom nom
    &lt;/p&gt;
  &lt;/div&gt;
  

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h2&gt;Ingredients&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;4 eggs - beaten \ whip together by
1c oil          / drizzling in slowly
2c sugar
2c brown sugar
5c oats (rolled or ground)
4c flour
2 tsp baking soda
2 tsp baking powder
1 1/2 tsp salt
2 tsp vanilla
2c chocolate chips
3c nuts (optional)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Directions&lt;/h2&gt;

&lt;p&gt;Add all the dry ingredients together in a mixer and stir them
together.  Whip the eggs, oil and vanilla together separately and then
add it slowly to the dry ingredients in the mixer as it runs.&lt;/p&gt;

&lt;p&gt;Depending on how many cookies I need, I use either a &amp;frac12; cup or &amp;frac14;
cup scoop for each cookie.  Bake on greased cookie sheets at 375F for
~10 minutes.  On our oven, I usually do around 12 minutes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Running form focuses</title>
      <link>http://nwidger.github.io/post/running-form-focuses/</link>
      <pubDate>Fri, 20 Dec 2013 00:00:00 UTC</pubDate>
      <author>Niels Widger</author>
      <guid>http://nwidger.github.io/post/running-form-focuses/</guid>
      <description>&lt;p&gt;This post lays out the form focuses I try to concentrate on when I&amp;rsquo;m
out for a run.  A lot of the core ideas are from the
&lt;a href=&#34;http://www.chirunning.com/&#34;&gt;ChiRunning&lt;/a&gt; method.  I have also found
that &lt;a href=&#34;http://fellrnr.com/wiki/Main_Page&#34;&gt;fellrnr&amp;rsquo;s Wiki&lt;/a&gt; has a ton of
valuable running information, including running form.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve laid out my form focuses by body part, from the feet to the head.&lt;/p&gt;

&lt;h2&gt;Breathing&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Inhale through your nose, exhale through your mouth.  If you can do
all your breathing through your nose, even better.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Time your breathing with your footfalls.  Inhale for 4 steps and
then exhale for 3 steps.  Increase this to inhale for 3 steps,
exhale for 2 steps for faster paces/hills.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Lower Body&lt;/h2&gt;

&lt;h3&gt;Legs&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Let your legs swing out behind your hips rather than in front.
Don&amp;rsquo;t pull your legs in front of your hips during your stride as
this will likely lead to heal striking.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Feet&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t splay your feet, keep the toes of both feet pointed forward in
the direction you wish to travel.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Land on your midfoot instead of your heel with your foot underneath
your hips.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Aim for a cadence of 90 spm (steps per minute) per foot, or 180 spm
if you&amp;rsquo;re counting footfalls on both feet.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Relax your feet, don&amp;rsquo;t push off with your toes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ldquo;Peel&amp;rdquo; your feet off the ground starting from your heel.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Ankles&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Lean forward from your ankles.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Knees&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Land with your knees slightly bent&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Keep your knees down, don&amp;rsquo;t lift your legs up.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Hips&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Keep your pelvis level by pulling your tailbone in using your core
muscles.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Allow a slight rotation in your hip during your stride, but keep the
rotation isolated to your hips/back and not your upper body.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Back&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Keep your back straight, don&amp;rsquo;t hunch.  Imagine a line going from the
top of your head, down through your tail bone to your heels and try
to keep that line straight.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Upper Body&lt;/h2&gt;

&lt;h3&gt;Shoulders&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Keep your shoulders relaxed, don&amp;rsquo;t hunch your shoulders up or pull
them back.  Don&amp;rsquo;t rotate your shoulders as you run, instead keep
them perpendicular to the direction you wish to travel.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Arms&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Allow your arms to hang loosely from their sockets.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bend your arms at 45-90 degree angles&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Keep your arms tucked in at your sides&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swing your arms forward to back, parallel to the direction you wish
to travel.  Don&amp;rsquo;t swing your arms laterally.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Keep your swing motion restricted so that your hand doesn&amp;rsquo;t go
behind your torso on the back swing and your elbow doesn&amp;rsquo;t go in
front of your torso on the forward swing.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Head/Neck&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Keep your chin down and your head back, imagine the straight line
going from your head to your toes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t stare at your feet, keep your head up looking at the road in
front of you.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Making a reveal.js presentation with org-reveal</title>
      <link>http://nwidger.github.io/post/making-a-reveal.js-presentation-with-org-reveal/</link>
      <pubDate>Thu, 19 Dec 2013 00:00:00 UTC</pubDate>
      <author>Niels Widger</author>
      <guid>http://nwidger.github.io/post/making-a-reveal.js-presentation-with-org-reveal/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m currently working on putting together the presentation for my
thesis defense and like all other things I wanted to put it together
inside Emacs.  I had heard of
&lt;a href=&#34;https://github.com/hakimel/reveal.js/&#34;&gt;reveal.js&lt;/a&gt; and wanted to give
it a shot for a while, and fortunately someone made
&lt;a href=&#34;https://github.com/yjwen/org-reveal&#34;&gt;org-reveal&lt;/a&gt; which allows
exporting an &lt;a href=&#34;http://orgmode.org&#34;&gt;org-mode&lt;/a&gt; file to a reveal.js
presentation.  Here&amp;rsquo;s how I put together my presentation.&lt;/p&gt;

&lt;h2&gt;Create your presentation directory&lt;/h2&gt;

&lt;p&gt;First make a directory to hold your presentation file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mkdir presentation
cd presentation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create a directory inside to hold any images you may use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mkdir images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create a &lt;code&gt;presentation.css&lt;/code&gt; file to store any custom CSS rules you may
need:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;touch presentation.css
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Install org-reveal&lt;/h2&gt;

&lt;p&gt;Obviously, &lt;code&gt;org-reveal&lt;/code&gt; requires &lt;code&gt;org&lt;/code&gt;.  &lt;code&gt;org&lt;/code&gt; ships with Emacs by
default, but I install it out of &lt;a href=&#34;http://melpa.milkbox.net/#/&#34;&gt;MELPA&lt;/a&gt;
to ensure I&amp;rsquo;m running the latest version.  To install &lt;code&gt;org&lt;/code&gt; and
&lt;code&gt;org-reveal&lt;/code&gt;, first add MELPA to your package repositories in your
Emacs init file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;lisp&#34;&gt;(package-initialize)
    
(add-to-list &#39;package-archives
         &#39;(&amp;quot;melpa&amp;quot; . &amp;quot;http://melpa.milkbox.net/packages/&amp;quot;) t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Evaluate that code with &lt;code&gt;eval-region&lt;/code&gt; or just restart Emacs.  Make
sure your package list is up to date by running &lt;code&gt;M-x
package-refresh-contents&lt;/code&gt;, then run &lt;code&gt;M-x package-install org RET&lt;/code&gt; and
then &lt;code&gt;M-x package-install ox-reveal RET&lt;/code&gt; to install both packages.&lt;/p&gt;

&lt;p&gt;I added the following to my Emacs init file to ensure they both get
loaded on startup (add this &lt;em&gt;after&lt;/em&gt; the call to &lt;code&gt;package-initialize&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;lisp&#34;&gt;(require &#39;org)
(require &#39;ox-reveal)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Install reveal.js&lt;/h2&gt;

&lt;p&gt;Next download the latest
&lt;a href=&#34;https://github.com/hakimel/reveal.js/releases&#34;&gt;reveal.js release&lt;/a&gt;
tarball and extract it to the &lt;code&gt;presentation&lt;/code&gt; directory.  Rename the
resulting directory to &lt;code&gt;reveal.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;wget https://github.com/hakimel/reveal.js/archive/2.6.1.tar.gz
tar xfz 2.6.1.tar.gz
mv reveal.js-2.6.1 reveal.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go into the &lt;code&gt;reveal.js&lt;/code&gt; directory and use &lt;code&gt;npm&lt;/code&gt; to download the
necessary dependencies (&lt;code&gt;reveal.js&lt;/code&gt; requires
&lt;a href=&#34;http://nodejs.org/&#34;&gt;Node.js&lt;/a&gt; and
&lt;a href=&#34;http://gruntjs.com/getting-started#installing-the-cli&#34;&gt;Grunt&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;cd reveal.js
sudo npm install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;follow the
&lt;a href=&#34;https://github.com/hakimel/reveal.js/#installation&#34;&gt;reveal.js install instructions&lt;/a&gt;
if you run into any problems here.&lt;/p&gt;

&lt;h2&gt;Create presentation file&lt;/h2&gt;

&lt;p&gt;Create a &lt;code&gt;presentation.org&lt;/code&gt; file and add the following header to the
top:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+REVEAL_MARGIN: 0.2
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: night
#+REVEAL_HLEVEL: 999
#+REVEAL_EXTRA_CSS: ./presentation.css

#+TITLE: My Title Goes Here
#+AUTHOR: Your Name Goes Here
#+EMAIL: your.email@goes.here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will probably want to play around with &lt;code&gt;REVEAL_THEME&lt;/code&gt; (choices
&lt;a href=&#34;https://github.com/hakimel/reveal.js/#theming&#34;&gt;here&lt;/a&gt;), &lt;code&gt;REVEAL_TRANS&lt;/code&gt;
(the slide transition effect, must be one of &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;cube&lt;/code&gt;,
&lt;code&gt;page&lt;/code&gt;, &lt;code&gt;concave&lt;/code&gt;, &lt;code&gt;zoom&lt;/code&gt;, &lt;code&gt;linear&lt;/code&gt;, &lt;code&gt;fade&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt;) and
&lt;code&gt;REVEAL_HLEVEL&lt;/code&gt;.  I set &lt;code&gt;REVEAL_HLEVEL&lt;/code&gt; to 999 so that all slides are
horizontal, see &lt;a href=&#34;https://github.com/yjwen/org-reveal#the-hlevel&#34;&gt;here&lt;/a&gt;
for details.  Note the &lt;code&gt;REVEAL_EXTRA_CSS&lt;/code&gt; option which pulls in any
extra CSS rules you&amp;rsquo;ve added to your &lt;code&gt;presentation.css&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;Now you can start creating your presentation.  Each heading
corresponds to a new slide.&lt;/p&gt;

&lt;h3&gt;Images&lt;/h3&gt;

&lt;p&gt;Images can be inserted into your presentation like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;[[./images/myimage.png]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can use put &lt;code&gt;#+ATTR_HTML :attr1 attr1_value, :attr2 attr2_value&lt;/code&gt;
above the image link to add custom HTML attributes, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;#+ATTR_HTML: :height 200%, :width 200%
[[./images/myimage.png]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Tables&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;org&lt;/code&gt; tables are also exported properly, although I found they look
better when stretched to fill the screen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;no-highlight&#34;&gt;#+ATTR_HTML: :width 100%
| column_title1  | column_title2 |
|----------------+---------------|
| a              | b             |
| a              | b             |
| a              | b             |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also added a few custom rules to &lt;code&gt;presentation.css&lt;/code&gt; to center the
table text and put a border around the cells:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;css&#34;&gt;.reveal table th, .reveal table td {
    text-align: center;
    border: 1px solid white;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Code Fragments&lt;/h3&gt;

&lt;p&gt;You can insert source code between &lt;code&gt;#+BEGIN_SRC&lt;/code&gt; and &lt;code&gt;#+END_SRC&lt;/code&gt;.  If
you specify the language you get awesome syntax highlighting for free
thanks to &lt;code&gt;org-babel&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;class MyClass extends Object {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I found that the code blocks weren&amp;rsquo;t displaying correctly due to the
&lt;code&gt;pre&lt;/code&gt; blocks being set to &lt;code&gt;width: 90%&lt;/code&gt;.  I fixed this by adding the
following rule to my &lt;code&gt;presentation.css&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;css&#34;&gt;.reveal pre {
    width: 100%;
    border: none;
    box-shadow: none;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Speaker&amp;rsquo;s notes&lt;/h3&gt;

&lt;p&gt;You can add speaker&amp;rsquo;s notes to each slide between &lt;code&gt;#+BEGIN_NOTES&lt;/code&gt; and
&lt;code&gt;#+END_NOTES&lt;/code&gt;.  While viewing your presentation, press &lt;code&gt;s&lt;/code&gt; to pull up
the speaker&amp;rsquo;s window to see your notes.&lt;/p&gt;

&lt;h2&gt;Generate the presentation&lt;/h2&gt;

&lt;p&gt;Generate your presentation by running &lt;code&gt;C-c C-e R R&lt;/code&gt;.  Once it&amp;rsquo;s
finished, there should be a new &lt;code&gt;presentation.html&lt;/code&gt; file.  Just open
it in your browser to view your presentation!  Press &lt;code&gt;f&lt;/code&gt; to go
fullscreen or &lt;code&gt;Esc&lt;/code&gt; to see the slide overview.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
